using Microsoft.CodeAnalysis;

using System;
using System.Text;

namespace InternalSourceGenerator;

[Generator]
public class ArrayExtensionsForEachActionsGenerator : ISourceGenerator
{
    /// <summary>
    /// Called before generation occurs. A generator can use the <paramref name="context" />
    /// to register callbacks required to perform generation.
    /// </summary>
    /// <param name="context">The <see cref="T:Microsoft.CodeAnalysis.GeneratorInitializationContext" /> to register callbacks on</param>
    public void Initialize(GeneratorInitializationContext context) { }

    /// <summary>
    /// Called to perform source generation. A generator can use the <paramref name="context" />
    /// to add source files via the <see cref="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)" />
    /// method.
    /// </summary>
    /// <param name="context">The <see cref="T:Microsoft.CodeAnalysis.GeneratorExecutionContext" /> to add source to</param>
    /// <remarks>
    /// This call represents the main generation step. It is called after a <see cref="T:Microsoft.CodeAnalysis.Compilation" /> is
    /// created that contains the user written code.
    /// A generator can use the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.Compilation" /> property to
    /// discover information about the users compilation and make decisions on what source to
    /// provide.
    /// </remarks>
    public void Execute(GeneratorExecutionContext context)
    {
        const string baseNamespace = "IX.Library";
        const string collectionsNamespace = $"{baseNamespace}.Collections";
        const string arrayExtensionsClassName = "ArrayExtensions";
        const int numberOfParametersToDealWith = 8;
        const string indentation = "    ";

        // Start building up for ArrayExtensions
        var indentationCount = 0;
        StringBuilder arrayExtensionsStringBuilder = new();
        arrayExtensionsStringBuilder.AppendLine("// <auto-generated/>");
        arrayExtensionsStringBuilder.AppendLine("using System.Diagnostics.CodeAnalysis;");
        arrayExtensionsStringBuilder.AppendLine();
        arrayExtensionsStringBuilder.AppendLine($"namespace {collectionsNamespace};");
        arrayExtensionsStringBuilder.AppendLine();
        arrayExtensionsStringBuilder.AppendLine($"public static partial class {arrayExtensionsClassName}");
        arrayExtensionsStringBuilder.AppendLine("{");

        var currentIndentation = string.Empty;

        void IncreaseIndentation()
        {
            indentationCount++;

            currentIndentation = MakeIndentation(indentationCount);
        }

        void DecreaseIndentation()
        {
            indentationCount--;

            if (indentationCount < 0) indentationCount = 0;

            currentIndentation = MakeIndentation(indentationCount);
        }

        string MakeIndentation(int count)
        {
            if (count <= 0) return string.Empty;
            if (count == 1) return indentation;

            StringBuilder sb = new();
            for (int j = 0; j < count; j++)
            {
                sb.Append(indentation);
            }

            return sb.ToString();
        }

        void WriteXmlDocSummary(string summary)
        {
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}/// <summary>");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}///     {summary}.");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}/// </summary>");
        }

        void WriteXmlDocArgumentNullException(params string[] argumentNames)
        {
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}/// <exception cref=\"ArgumentNullException\">");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}///     Thrown when");

            for (var j = 0; j < argumentNames.Length; j++)
            {
                if (j != 0) arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}///     or ");
                arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}///     <paramref name=\"{argumentNames[j]}\" />");
            }
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}///     is <see langword=\"null\"/> (<see langword=\"Nothing\"/> in Visual Basic).");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}/// </exception>");
        }

        void WriteXmlDocTypeParam(
            string paramName,
            string description)
        {
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}/// <typeparam name=\"{paramName}\">{description}</typeparam>");
        }

        void WriteXmlDocParam(
            string paramName,
            string description)
        {
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}/// <param name=\"{paramName}\">{description}</param>");
        }

        void WriteXmlDocReturn(
            string description)
        {
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}/// <returns>{description}</returns>");
        }

        void WriteForLoopWarningSuppression()
        {
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}[SuppressMessage(\"ReSharper\", \"ForCanBeConvertedToForeach\", Justification = \"A for loop on an array is going to be faster.\")]");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}[SuppressMessage(\"CodeQuality\", \"IDE0079:Remove unnecessary suppression\", Justification = \"ReSharper is used for this project.\")]");
        }

        // Build up source for ArrayExtensions.ForEachActions
        IncreaseIndentation();
        for (var i = 1; i <= numberOfParametersToDealWith; i++)
        {
            void WriteXmlDocTypeParamTags(string descriptionFragment)
            {
                for (var j = 1; j <= i; j++)
                {
                    arrayExtensionsStringBuilder.AppendLine(
                        $"{currentIndentation}/// <typeparam name=\"TParam{j}\">The type of parameter {descriptionFragment} at index {j - 1}.</typeparam>");
                }
            }

            void WriteXmlDocParamTags(string descriptionFragment)
            {
                for (var j = 1; j <= i; j++)
                {
                    arrayExtensionsStringBuilder.AppendLine(
                        $"{currentIndentation}/// <param name=\"param{j}\">A parameter of type <typeparamref name=\"TParam{j}\" /> {descriptionFragment} at index {j - 1}.</param>");
                }
            }

            void WriteFunctionHeader(
                string functionName,
                string returnType = "void",
                string typeParametersBefore = "",
                bool isAsync = false)
            {
                arrayExtensionsStringBuilder.Append($"{currentIndentation}public static {(isAsync ? "async " : string.Empty)}{returnType} {functionName}<");
                if (!string.IsNullOrWhiteSpace(typeParametersBefore)) arrayExtensionsStringBuilder.Append($"{typeParametersBefore}, ");

                for (var j = 1; j <= i; j++)
                {
                    arrayExtensionsStringBuilder.Append($"TParam{j}");
                    if (j != i) arrayExtensionsStringBuilder.Append(", ");
                }

                arrayExtensionsStringBuilder.AppendLine(">(");
            }

            // Method 1: ForEach
            // =================

            // XML documentation
            WriteXmlDocSummary("Executes an action for each one of the elements of an array.");
            WriteXmlDocTypeParam(
                "TItem",
                "The array type.");
            WriteXmlDocTypeParamTags("to be passed to the invoked method");
            WriteXmlDocParam(
                "source",
                "The enumerable source.");
            WriteXmlDocParam(
                "action",
                "The action to execute.");
            WriteXmlDocParamTags("to pass to the invoked method");
            WriteXmlDocArgumentNullException(
                "source",
                "action");

            // Header
            WriteForLoopWarningSuppression();
            WriteFunctionHeader(
                "ForEach",
                typeParametersBefore: "TItem");
            IncreaseIndentation();
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}this TItem[] source,");

            arrayExtensionsStringBuilder.Append($"{currentIndentation}Action<TItem, ");

            for (var j = 1; j <= i; j++)
            {
                if (j > 1) arrayExtensionsStringBuilder.Append(", ");
                arrayExtensionsStringBuilder.Append($"TParam{j}");
            }

            arrayExtensionsStringBuilder.AppendLine("> action,");

            for (var j = 1; j <= i; j++)
            {
                if (j > 1) arrayExtensionsStringBuilder.AppendLine(",");
                arrayExtensionsStringBuilder.Append($"{currentIndentation}TParam{j} param{j}");
            }

            arrayExtensionsStringBuilder.AppendLine(")");
            DecreaseIndentation();
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}{{");
            IncreaseIndentation();

            // Body
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}Requires.NotNull(source);");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}Requires.NotNull(action);");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}for (var i = 0; i < source.Length; i++)");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}{{");
            IncreaseIndentation();

            arrayExtensionsStringBuilder.Append($"{currentIndentation}action(source[i], ");

            for (var j = 1; j <= i; j++)
            {
                if (j > 1) arrayExtensionsStringBuilder.Append(", ");
                arrayExtensionsStringBuilder.Append($"param{j}");
            }

            arrayExtensionsStringBuilder.AppendLine(");");
            DecreaseIndentation();

            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}}}");

            // End
            DecreaseIndentation();
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}}}");
            arrayExtensionsStringBuilder.AppendLine();

            // Method 2: ForEachAsync
            // ======================

            // XML documentation
            WriteXmlDocSummary("Asynchronously executes an action for each one of the elements of an array.");
            WriteXmlDocTypeParam(
                "TItem",
                "The array type.");
            WriteXmlDocTypeParamTags("to be passed to the invoked method");
            WriteXmlDocParam(
                "source",
                "The enumerable source.");
            WriteXmlDocParam(
                "action",
                "The action to execute.");
            WriteXmlDocParamTags("to pass to the invoked method");
            WriteXmlDocParam(
                "cancellationToken",
                "The cancellation token for this operation.");
            WriteXmlDocArgumentNullException(
                "source",
                "action");
            WriteXmlDocReturn("A <see cref=\"ValueTask\" /> representing the current operation.");

            // Header
            WriteForLoopWarningSuppression();
            WriteFunctionHeader(
                "ForEachAsync",
                returnType: "ValueTask",
                typeParametersBefore: "TItem",
                isAsync: true);
            IncreaseIndentation();
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}this TItem[] source,");

            arrayExtensionsStringBuilder.Append($"{currentIndentation}Func<TItem, ");

            for (var j = 1; j <= i; j++)
            {
                if (j > 1) arrayExtensionsStringBuilder.Append(", ");
                arrayExtensionsStringBuilder.Append($"TParam{j}");
            }

            arrayExtensionsStringBuilder.AppendLine(", Task> action,");

            for (var j = 1; j <= i; j++)
            {
                if (j > 1) arrayExtensionsStringBuilder.AppendLine(",");
                arrayExtensionsStringBuilder.Append($"{currentIndentation}TParam{j} param{j}");
            }

            arrayExtensionsStringBuilder.AppendLine(",");
            arrayExtensionsStringBuilder.AppendLine("CancellationToken cancellationToken = default)");
            DecreaseIndentation();
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}{{");
            IncreaseIndentation();

            // Body
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}Requires.NotNull(source);");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}Requires.NotNull(action);");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}if (cancellationToken.IsCancellationRequested) return;");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}for (var i = 0; i < source.Length; i++)");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}{{");
            IncreaseIndentation();

            arrayExtensionsStringBuilder.Append($"{currentIndentation}await action(source[i], ");

            for (var j = 1; j <= i; j++)
            {
                if (j > 1) arrayExtensionsStringBuilder.Append(", ");
                arrayExtensionsStringBuilder.Append($"param{j}");
            }

            arrayExtensionsStringBuilder.AppendLine(");");
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}cancellationToken.ThrowIfCancellationRequested();");

            DecreaseIndentation();
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}}}");

            // End
            DecreaseIndentation();
            arrayExtensionsStringBuilder.AppendLine($"{currentIndentation}}}");
            arrayExtensionsStringBuilder.AppendLine();

        }

/*
    /// <remarks>
    ///     <para>This method, due to multiple awaits, is considered to be very slow compared to its synchronous version.</para>
    ///     <para>Please make sure to only use this where asynchronicity is required.</para>
    ///     <para>In CPU-intensive operations, only its synchronous counterpart should be used.</para>
    /// </remarks>

    /// <summary>
    ///     Asynchronously executes an action for each one of the elements of an array.
    /// </summary>
    /// <typeparam name="TItem">The array type.</typeparam>
<#
    for (int j = 1; j <= i; j++)
    {
#>
    /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
    /// <param name="source">The enumerable source.</param>
    /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
    /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
    /// <param name="cancellationToken">The cancellation token for this operation.</param>
    /// <returns>A <see cref="ValueTask" /> representing the current operation.</returns>
    /// <exception cref="ArgumentNullException">
    ///     Thrown when <paramref name="source" /> or <paramref name="action" /> is
    ///     <see langword="null"/> (<see langword="Nothing"/> in Visual Basic).
    /// </exception>
    /// <remarks>
    ///     <para>This method, due to multiple awaits, is considered to be very slow compared to its synchronous version.</para>
    ///     <para>Please make sure to only use this where asynchronicity is required.</para>
    ///     <para>In CPU-intensive operations, only its synchronous counterpart should be used.</para>
    /// </remarks>
    [SuppressMessage(
        "ReSharper",
        "ForCanBeConvertedToForeach",
        Justification = "A for loop on an array is going to be faster.")]
    [SuppressMessage(
        "CodeQuality",
        "IDE0079:Remove unnecessary suppression",
        Justification = "ReSharper is used for this project.")]
    public static async ValueTask ForEachAsync<TItem, <#= paramTypes #>>(
        this TItem[] source,
        Func<TItem, <#= paramTypes #>, ValueTask> action,
        <#= paramNameTypes #>,
        CancellationToken cancellationToken = default)
    {
        Requires.NotNull(source);
        Requires.NotNull(action);

        if (cancellationToken.IsCancellationRequested)
        {
            return;
        }

        for (var i = 0; i < source.Length; i++)
        {
            await action(source[i], <#= paramNames #>);
            cancellationToken.ThrowIfCancellationRequested();
        }
    }

    /// <summary>
    ///     Asynchronously executes an action for each one of the elements of an array.
    /// </summary>
    /// <typeparam name="TItem">The array type.</typeparam>
<#
    for (int j = 1; j <= i; j++)
    {
#>
    /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
    /// <param name="source">The enumerable source.</param>
    /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
    /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
    /// <param name="cancellationToken">The cancellation token for this operation.</param>
    /// <returns>A <see cref="ValueTask" /> representing the current operation.</returns>
    /// <exception cref="ArgumentNullException">
    ///     Thrown when <paramref name="source" /> or <paramref name="action" /> is
    ///     <see langword="null"/> (<see langword="Nothing"/> in Visual Basic).
    /// </exception>
    /// <remarks>
    ///     <para>This method, due to multiple awaits, is considered to be very slow compared to its synchronous version.</para>
    ///     <para>Please make sure to only use this where asynchronicity is required.</para>
    ///     <para>In CPU-intensive operations, only its synchronous counterpart should be used.</para>
    /// </remarks>
    [SuppressMessage(
        "ReSharper",
        "ForCanBeConvertedToForeach",
        Justification = "A for loop on an array is going to be faster.")]
    [SuppressMessage(
        "CodeQuality",
        "IDE0079:Remove unnecessary suppression",
        Justification = "ReSharper is used for this project.")]
    public static async ValueTask ForEachAsync<TItem, <#= paramTypes #>>(
        this TItem[] source,
        Func<TItem, <#= paramTypes #>, CancellationToken, Task> action,
        <#= paramNameTypes #>,
        CancellationToken cancellationToken = default)
    {
        Requires.NotNull(source);
        Requires.NotNull(action);

        if (cancellationToken.IsCancellationRequested)
        {
            return;
        }

        for (var i = 0; i < source.Length; i++)
        {
            await action(source[i], <#= paramNames #>, cancellationToken);
            cancellationToken.ThrowIfCancellationRequested();
        }
    }

    /// <summary>
    ///     Asynchronously executes an action for each one of the elements of an array.
    /// </summary>
    /// <typeparam name="TItem">The array type.</typeparam>
<#
    for (int j = 1; j <= i; j++)
    {
#>
    /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
    /// <param name="source">The enumerable source.</param>
    /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
    /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
    /// <param name="cancellationToken">The cancellation token for this operation.</param>
    /// <returns>A <see cref="ValueTask" /> representing the current operation.</returns>
    /// <exception cref="ArgumentNullException">
    ///     Thrown when <paramref name="source" /> or <paramref name="action" /> is
    ///     <see langword="null"/> (<see langword="Nothing"/> in Visual Basic).
    /// </exception>
    /// <remarks>
    ///     <para>This method, due to multiple awaits, is considered to be very slow compared to its synchronous version.</para>
    ///     <para>Please make sure to only use this where asynchronicity is required.</para>
    ///     <para>In CPU-intensive operations, only its synchronous counterpart should be used.</para>
    /// </remarks>
    [SuppressMessage(
        "ReSharper",
        "ForCanBeConvertedToForeach",
        Justification = "A for loop on an array is going to be faster.")]
    [SuppressMessage(
        "CodeQuality",
        "IDE0079:Remove unnecessary suppression",
        Justification = "ReSharper is used for this project.")]
    public static async ValueTask ForEachAsync<TItem, <#= paramTypes #>>(
        this TItem[] source,
        Func<TItem, <#= paramTypes #>, CancellationToken, ValueTask> action,
        <#= paramNameTypes #>,
        CancellationToken cancellationToken = default)
    {
        Requires.NotNull(source);
        Requires.NotNull(action);

        if (cancellationToken.IsCancellationRequested)
        {
            return;
        }

        for (var i = 0; i < source.Length; i++)
        {
            await action(source[i], <#= paramNames #>, cancellationToken);
            cancellationToken.ThrowIfCancellationRequested();
        }
    }
<#
}
#>
*/
        // Build up source for ArrayExtensions.ForEachRefActions

        // Build up source for ArrayExtensions.SequenceCompare.StandardTypes

        // Build up source for ArrayExtensions.SequenceEquals.StandardTypes

        // Build up source for ArrayExtensions.StandardTypes

        // End building for ArrayExtensions
        arrayExtensionsStringBuilder.AppendLine("}");

        context.AddSource("ArrayExtensions.g.cs", arrayExtensionsStringBuilder.ToString());
    }
}
